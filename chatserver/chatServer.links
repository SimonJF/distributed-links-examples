open ChatSessions
open ChatClient

module MainServer {

    typename ServerMessage =
        [&| BroadcastMessage: ?(Nickname, Message). End,
            BroadcastChangeTopic: ?Topic. End,
            NewClient: ?(Nickname, ServerToClientChannel). End,
            GetServerState: !(Topic, [Nickname]). End |&];

    var ap = (new(): AP(ServerMessage));

    # Main server loop, containing server state. Awaits (non-session) control
    # messages to update the state, or broadcast instructions to send things
    # along session channels.
    sig serverLoop : (Topic, [Nickname], LinList(ServerToClientChannel)) ~%~> ()
    fun serverLoop(topic, nicks, chans) {
      var ch = accept(ap);
      offer(ch) {
        case BroadcastMessage(ch) ->
          var ((nick, msg), _) = receive(ch);
          var chans = broadcastMessage(
            fun(c) {
                var c = select IncomingChatMessage c;
                send ((nick, msg), c)
            }, chans);
          serverLoop(topic, nicks, chans)
        case BroadcastChangeTopic(ch) ->
          var (newTopic, _) = receive(ch);
          var chans = broadcastMessage(
            fun(c) {
                var c = select NewTopic c;
                send (newTopic, c)
            }, chans);
          serverLoop(newTopic, nicks, chans)
        case NewClient(ch) ->
          var ((nick, newCh), _) = receive(ch);
          var chans = broadcastMessage(
            fun(c) {
                var c = select NewUser c;
                send (nick, c)
            }, chans);
          serverLoop(topic, nick :: nicks, LinCons(newCh, chans))
        case GetServerState(ch) ->
          ignore(send((topic, nicks), ch));
          serverLoop(topic, nicks, chans)
      }
    }

    # Maps a function over all channels
    sig broadcastMessage : (
        ((ServerToClientChannel) ~%~> ServerToClientChannel),
        LinList(ServerToClientChannel)) ~%~> LinList(ServerToClientChannel)
    fun broadcastMessage(f, chans) {
      switch(chans) {
        case LinNil -> LinNil
        case LinCons(ch, chs) ->  LinCons(f(ch), (broadcastMessage(f, chs)))
      }
    }

    fun broadcastChatMessage(nick, msg) {
        var s = request(ap);
        var s = select BroadcastMessage s;
        ignore(send((nick, msg), s))
    }

    fun broadcastChangeTopic(newTopic) {
        var s = request(ap);
        var s = select BroadcastChangeTopic s;
        ignore(send(newTopic, s))
    }

    fun broadcastNewClient(nick, ch) {
        var s = request(ap);
        var s = select NewClient s;
        ignore(send((nick, ch), s))
    }

    fun getServerState() {
        var s = request(ap);
        var s = select GetServerState s;
        var (res, _) = receive(s);
        res
    }
}

## clientHandler loop: Reads incoming requests from the client, dispatches
## each command to the serverLoop which will broadcast to other session clients.
# Alas, we can't make this an inner function at the moment since we need a type
# annotation, and type annotations are broken for inner functions at the moment
sig clientHandlerLoop: (Nickname, ReceiveCommand) ~%~> ()
fun clientHandlerLoop(nick, clientToServerChan) {

  offer(clientToServerChan) {
    case ChatMessage(clientToServerChan) ->
      var (msg, clientToServerChan) = receive(clientToServerChan);
      MainServer.broadcastChatMessage(nick, msg);
      clientHandlerLoop(nick, clientToServerChan)
    case ChangeTopic(clientToServerChan) ->
      var (newTopic, clientToServerChan) = receive(clientToServerChan);
      MainServer.broadcastChangeTopic(newTopic);
      clientHandlerLoop(nick, clientToServerChan)
  }
}


# Process that is spawned to handle messages from the chat client.
fun clientHandler(nick, chatServerRecvEnd, serverToClientRecvEnd) {

  # Get the current topic and nicks
  var (topic, nicks) = MainServer.getServerState();

  # Send topic, nicks, and outgoing channel
  var chatServerRecvEnd =
    send((topic, nicks, serverToClientRecvEnd), chatServerRecvEnd);

  clientHandlerLoop(nick, chatServerRecvEnd)
}

fun clientSendHandler(s) {
  receive {
    case DeliverMessage(nick, msg) ->
      var s = select IncomingChatMessage s;
      var s = send((nick, msg), s);
      clientSendHandler(s)
    case DeliverNewUser(nick) ->
      var s = select NewUser s;
      var s = send(nick, s);
      clientSendHandler(s)
    case DeliverNewTopic(topic) ->
      var s = select NewTopic s;
      var s = send(topic, s);
      clientSendHandler(s)
    case DeliverUserLeft(nick) ->
      var s = select UserLeft s;
      var s = send(nick, s);
      clientSendHandler(s)
  }
}


sig handleNewClient : (ChatServer) ~%~> ()
fun handleNewClient(clientToServer) {
  # Get the name of the new client.
  var (name, clientToServer) = receive(clientToServer);

  # Fork off the client handler
  var serverToClient = linFork(
    linfun (serverToClient) {
      clientHandler(name, clientToServer, serverToClient)
  });

  # Fork off client send handler
  # var pid = spawn { clientSendHandler(serverToClient) };

  # Register with the main loop
  MainServer.broadcastNewClient(name, serverToClient);
}

fun acceptor(ap: AP(ChatServer)) server {
  # Accept a new client
  var clientToServer = accept(ap);
  var _ = spawn { handleNewClient(clientToServer) };
  acceptor(ap)
}

fun main() {
  var (clientAP:AP(ChatServer)) = new();
  var _ = spawn { MainServer.serverLoop(Topic("Hello, ABCD!"), [], LinNil) };
  var _ = spawn { acceptor(clientAP) };
  addRoute("/", fun(_) { ChatClient.mainPage(clientAP) } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets();
  servePages()
}

main()
