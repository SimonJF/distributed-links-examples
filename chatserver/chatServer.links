open ChatSessions
open ChatClient

module MainServer {

    typename ServerMessage =
        [&| BroadcastMessage: ?(Nickname, Message). End,
            BroadcastChangeTopic: ?Topic. End,
            NewClient: ?(Nickname, ServerToClientChannel). End,
            ClientLeft: ?Nickname. End,
            GetServerState: !(Topic, [Nickname]). End |&];

    var ap = (new(): AP(ServerMessage));

    # Main server loop, containing server state. Awaits (non-session) control
    # messages to update the state, or broadcast instructions to send things
    # along session channels.
    sig serverLoop : (Topic, [Nickname], LinList(ServerToClientChannel)) ~%~> ()
    fun serverLoop(topic, nicks, chans) {
      var ch = accept(ap);
      offer(ch) {
        case BroadcastMessage(ch) ->
          var ((nick, msg), _) = receive(ch);
          var chans = broadcastMessage(
            fun(c) {
                var c = select IncomingChatMessage c;
                send ((nick, msg), c)
            }, chans);
          serverLoop(topic, nicks, chans)
        case BroadcastChangeTopic(ch) ->
          var (newTopic, _) = receive(ch);
          var chans = broadcastMessage(
            fun(c) {
                var c = select NewTopic c;
                send (newTopic, c)
            }, chans);
          serverLoop(newTopic, nicks, chans)
        case NewClient(ch) ->
          var ((nick, newCh), _) = receive(ch);
          var chans = broadcastMessage(
            fun(c) {
                var c = select NewUser c;
                send (nick, c)
            }, chans);
          serverLoop(topic, nick :: nicks, LinCons(newCh, chans))
        case ClientLeft(ch) ->
          var (nick, _) = receive(ch);
          var (nicks, chans) = deleteClient(nick, nicks, chans);
          var chans = broadcastMessage(
            fun(c) {
              var c = select UserLeft c;
              send(nick, c)
            }, chans);
          serverLoop(topic, nicks, chans)
        case GetServerState(ch) ->
          ignore(send((topic, nicks), ch));
          serverLoop(topic, nicks, chans)
      }
    }

    sig deleteClient :
      (Nickname, [Nickname], LinList(ServerToClientChannel)) ~%~>
      ([Nickname], LinList(ServerToClientChannel))
    fun deleteClient(deleteNick, nicks, chans) {
      var Nickname(toDelete) = deleteNick;
      switch ((nicks, chans)) {
        case ([], LinNil) -> ([], LinNil)
        case ((Nickname(nick) :: nicks), LinCons(chan, chans)) ->
          if (nick == toDelete) {
            cancel(chan);
            (nicks, chans)
          } else {
            var (restNicks, restChans) = deleteClient(deleteNick, nicks, chans);
            (Nickname(nick)::restNicks, LinCons(chan, restChans))
          }
      }
    }

    # Maps a function over all channels
    sig broadcastMessage : (
        ((ServerToClientChannel) ~%~> ServerToClientChannel),
        LinList(ServerToClientChannel)) ~%~> LinList(ServerToClientChannel)
    fun broadcastMessage(f, chans) {
      switch(chans) {
        case LinNil -> LinNil
        case LinCons(ch, chs) -> LinCons(f(ch), (broadcastMessage(f, chs)))
      }
    }


    fun userLeft(nick) {
        var s = request(ap);
        var s = select ClientLeft s;
        ignore(send(nick, s))
    }

    fun broadcastChatMessage(nick, msg) {
        var s = request(ap);
        var s = select BroadcastMessage s;
        ignore(send((nick, msg), s))
    }

    fun broadcastChangeTopic(newTopic) {
        var s = request(ap);
        var s = select BroadcastChangeTopic s;
        ignore(send(newTopic, s))
    }

    fun broadcastNewClient(nick, ch) {
        var s = request(ap);
        var s = select NewClient s;
        ignore(send((nick, ch), s))
    }

    fun getServerState() {
        var s = request(ap);
        var s = select GetServerState s;
        var (res, _) = receive(s);
        res
    }
}

## clientHandler loop: Reads incoming requests from the client, dispatches
## each command to the serverLoop which will broadcast to other session clients.
# Alas, we can't make this an inner function at the moment since we need a type
# annotation, and type annotations are broken for inner functions at the moment
#sig clientHandlerLoop: (Nickname, ReceiveCommand) ~%~> ()
fun clientHandlerLoop(nick, chan) {
  try {
    offer(chan) {
      case ChatMessage(chan) ->
        var (msg, chan) = receive(chan);
        MainServer.broadcastChatMessage(nick, msg);
        chan
      case ChangeTopic(chan) ->
        var (newTopic, chan) = receive(chan);
        MainServer.broadcastChangeTopic(newTopic);
        chan
    }
  } as (chan) in {
    clientHandlerLoop(nick, chan)
  } otherwise {
    MainServer.userLeft(nick)
  }
}


#sig handleNewClient : (ChatServer) ~%~> ()
fun handleNewClient(clientToServer) {
  # Get the name of the new client.
  var (name, clientToServer) = receive(clientToServer);

  # Fork off the client handler
  var serverToClient = linFork(
    linfun (serverToClient) {
      # Get the current topic and nicks
      var (topic, nicks) = MainServer.getServerState();
      # Send topic, nicks, and outgoing channel
      var clientToServer =
        send((topic, nicks, serverToClient), clientToServer);
      clientHandlerLoop(name, clientToServer)
  });

  # Register with the main loop
  MainServer.broadcastNewClient(name, serverToClient);
}

fun acceptor(ap: AP(ChatServer)) server {
  # Accept a new client
  var clientToServer = accept(ap);
  var _ = spawn { handleNewClient(clientToServer) };
  acceptor(ap)
}

fun main() {
  var (clientAP:AP(ChatServer)) = new();
  var _ = spawn { MainServer.serverLoop(Topic("Hello, ABCD!"), [], LinNil) };
  var _ = spawn { acceptor(clientAP) };
  addRoute("/", fun(_) { ChatClient.mainPage(clientAP) } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets();
  servePages()
}

main()
