open ChatSessions
open ChatClient
open Utility

#helper functions:
fun member(elem , l) {
  switch(l) {
    case [] -> false
    case (x::xs) -> x == elem || member(elem, xs)
  }
}

typename RoomJoinResponse =
  [| UsernameTaken
     | InvalidRoom
     | Joined: (Topic, ClientReceive)
     | JoinedAsModerator:
        (Topic, ClientReceive, ModeratorSend) |];
# Messages sent from workers and the room manager to
# a room. Note that is *not* exposed to clients directly.
# It is, however, the union of both the messages sent by
# client workers and the room manager.
# In future, I wonder whether some form of input-guarded choice-style
# operator on APs could make this more modular.
typename RoomReceive =
  [&|
      # Messages sent from client worker
      Chat: ?(Nickname, Message).End,
      NewTopic: ?Topic          .End,
      Leave: ?Nickname          .End,
      # Messages sent from moderator worker
      KickUser: ?Nickname       .End,
      MuteUser: ?Nickname       .End,
      MakeModerator: ?Nickname  .End,
      # Messages sent from room manager
      JoinRequest: ?Nickname.!RoomJoinResponse.End,
      Kill: End
  |&];

typename RoomHandle = AP(RoomReceive);


typename RoomJoinResult =
  [| UsernameTaken
   | InvalidRoom
   | Joined: (Topic, ClientReceive, RoomHandle)
   | JoinedAsModerator: (Topic, ClientReceive, ModeratorSend, RoomHandle) |];


module Moderator {
  sig create : (RoomHandle) ~> ModeratorSend
  fun create(roomAp) {
    fun loop(s) {
      offer(s) {
        case KickUser(s) ->
          var (nick, s) = receive(s);
          # Mutually-recursive modules don't work, so we will
          # need to send the messages manually.
          ignore(send(nick, select KickUser (request(roomAp))));
          loop(s)
        case MuteUser(s) ->
          var (nick, s) = receive(s);
          ignore(send(nick, select MuteUser (request(roomAp))));
          loop(s)
        case MakeModerator(s) ->
          var (nick, s) = receive(s);
          ignore(send(nick, select MakeModerator (request(roomAp))));
          loop(s)
      }
    }
    fork(loop)
  }
}

module Room {

  typename RoomState =
    (name:String,
     topic:String,
     ap:RoomHandle);

  # Gets us a pair of (RoomSend, ~RoomSend) endpoints.
  # Perhaps this should be in the standard library.
  sig createRoomSend : () ~> (RoomSend, ~RoomSend)
  fun createRoomSend() {
    var transit = new();
    var (ap: AP(RoomSend)) = new();
    var _ = spawn {
      var ep2 = request(ap);
      ignore(send(ep2, request(transit)))
    };
    var ep1 = accept(ap);
    var (ep2, _) = receive(accept(transit));
    (ep1, ep2)
  }

  sig loop : (RoomState, LinList((Nickname, RoomSend))) ~> ()
  fun loop(state, clients) {

    sig broadcastJoined : (Nickname, LinList((String, RoomSend))) ~> LinList((String, RoomSend))
    fun broadcastJoined(nick, clients) {
      AssocLinList.map(fun(s) {
        var s = select NewUser s;
        send(nick, s)
      }, clients)
    }

    var s = accept(state.ap);

    fun kickUser(nick, clients) {
      clients
    }

    fun muteUser(nick, clients) {
      clients
    }

    fun makeModerator(nick, clients) {
      clients
    }

    offer(s) {
      case JoinRequest(s) ->
        var (nick, s) = receive(s);
        # If username is already taken, let the client know
        var (nickTaken, clients) =
          AssocLinList.contains(nick, clients);
        if (nickTaken) {
          var _ = send(UsernameTaken, s);
          loop(state, clients)
        } else {
          # Otherwise, check if the user is the only one in the room.
          # If so, make them moderator
          var (isEmpty, clients) = AssocLinList.isEmpty(clients);
          if (isEmpty) {
            var (roomSend, clientReceive) = createRoomSend();
            var moderatorSend = Moderator.create(state.ap);
            var _ =
              send(JoinedAsModerator(state.topic,
                clientReceive, moderatorSend), s);
            loop(state, LinCons((nick, roomSend), clients))
          } else {
            var (roomSend, clientReceive) = createRoomSend();
            var clients = broadcastJoined(nick, clients);
            var _ = send(Joined(state.topic, clientReceive), s);
            loop(state, LinCons((nick, roomSend), clients))
          }
        }
      case Chat(s) ->
        var ((nick, msg), _) = receive(s);
        var clients = AssocLinList.map(fun(s) {
          var s = select IncomingChatMessage s;
          send ((nick, msg), s)
        }, clients);
        loop(state, clients)
      case NewTopic(s) ->
        var (newTopic, _) = receive(s);
        var clients = AssocLinList.map(fun(s) {
          var s = select NewTopic s;
          send(newTopic, s)
        }, clients);
        loop((state with topic=newTopic), clients)
      case Leave(s) ->
        var (name, _) = receive(s);
        var clients = AssocLinList.map(fun(s) {
          var s = select UserLeft s;
          send(name, s)
        }, clients);
        loop(state, clients)
      case KickUser(s) ->
        var (name, _) = receive(s);
        var clients = AssocLinList.map(fun(s) {
          var s = select UserLeft s;
          send(name, s)
        }, clients);
        var clients = kickUser(name, clients);
        loop(state, clients)
      case MuteUser(s) ->
        var (name, _) = receive(s);
        var clients = AssocLinList.map(fun(s) {
          var s = select UserMuted s;
          send(name, s)
        }, clients);
        var clients = muteUser(name, clients);
        loop(state, clients)
      case MakeModerator(s) ->
        var (name, _) = receive(s);
        var clients = makeModerator(name, clients);
        loop(state, clients)
      case Kill(s) ->
        # Since after selecting Kick, all elements will be of type End
        # (and therefore unrestricted), we can dispose of `clients`.
        var _ = AssocLinList.map(fun(s) { select Kick s }, clients);
        () # Stop evaluating
    }
  }

  sig join : (RoomHandle, Nickname) ~> RoomJoinResponse
  fun join(ap, nick) {
    var s = request(ap);
    var s = select JoinRequest s;
    var s = send(nick, s);
    var (res, _) = receive(s);
    res
  }

  sig create : (RoomName) ~> RoomHandle
  fun create(roomName) {
    var (ap: RoomHandle) = new();
    var (state: RoomState) =
      (name=roomName, topic="Hello, world!", ap=ap);
    var _ = spawn { loop(state, LinNil) };
    ap
  }

  sig kill : (RoomHandle) ~> ()
  fun kill(ap) {
    ignore(select Kill request(ap))
  }

  sig chatMessage : (RoomHandle, Nickname, Message) ~> ()
  fun chatMessage(ap, nick, msg) {
    var s = request(ap);
    var s = select Chat s;
    ignore(send((nick, msg), s))
  }

  sig newTopic : (RoomHandle, Topic) ~> ()
  fun newTopic(ap, topic) {
    var s = request(ap);
    var s = select NewTopic s;
    ignore(send(topic, s))
  }

  sig leave : (RoomHandle, Nickname) ~> ()
  fun leave(ap, nick) {
    var s = request(ap);
    var s = select Leave s;
    ignore(send(nick, s))
  }

}


module RoomManager {

  # Messages sent from the client to add / remove
  # / list / join rooms
  typename RoomManager =
    [&|
      RemoveRoom: ?RoomName.End,
      ListRooms: ![RoomName].End,
      ConnectToRoom: ?(Nickname, RoomName).!RoomJoinResult.End
    |&];


  sig managerAP : AP(RoomManager)
  var managerAP = new();


  fun roomExists(roomName, rooms) {
    AssocList.contains(roomName, rooms)
  }

  fun lookupRoom(roomName, rooms) {
    AssocList.lookup(roomName, rooms)
  }

  fun deleteRoom(roomName, rooms) {
    filter(fun((name, roomHandle)) {
      if (name == roomName) {
        Room.kill(roomHandle);
        false
      } else {
        true
      }
    }, rooms)
  }

  # Main loop for the room manager
  fun init() {

    fun getJoinResult(roomAp, nick) {
      switch(Room.join(roomAp, nick)) {
        case UsernameTaken -> UsernameTaken
        case InvalidRoom -> InvalidRoom
        case Joined(topic, cr) -> Joined(topic, cr, roomAp)
        case JoinedAsModerator(topic, cr, ms) ->
          JoinedAsModerator(topic, cr, ms, roomAp)
      }
    }

    fun loop(rooms) {
      var s = accept(managerAP);
      offer(s) {
        case RemoveRoom(s) ->
          var (roomName, _) = receive(s);
          loop(deleteRoom(roomName, rooms))
        case ListRooms(s) ->
          var _ = send(map(fun((name, _)) { name }, rooms), s);
          loop(rooms)
        case ConnectToRoom(s) ->
          var ((nick, roomName), s) = receive(s);
          switch(lookupRoom(roomName, rooms)) {
            case Just(roomAp) ->
              var _ = send(getJoinResult(roomAp, nick), s);
              loop(rooms)
            case Nothing ->
              var roomAp = Room.create(roomName);
              var _ = send(getJoinResult(roomAp, nick), s);
              loop(rooms ++ [(roomName, roomAp)])
          }
      }
    }
    # Spawn the room manager loop
    ignore(spawn { loop([]) })
  }


  fun removeRoom(name) {
    var s = request(managerAP);
    var s = select RemoveRoom s;
    ignore(send(name, s))
  }

  fun listRooms() {
    var s = request(managerAP);
    var s = select ListRooms s;
    var (rooms, _) = receive(s);
    rooms
  }

  fun connectToRoom(name, roomName) {
    var s = request(managerAP);
    var s = select ConnectToRoom s;
    var s = send((name, roomName), s);
    var (res, _) = receive(s);
    res
  }
}


# status : ( name:Room, topic:Topic, users:[User] )
# user : ( nick:Nickname, pid:ClientSendHandler, isAdmin:Bool,
#          isMuted:Bool )
# Main server loop that handles an individual room
# fun perRoomLoop(status) server {
#   fun removeUserByName(nick, users) {
#     switch(users) {
#       case [] -> []
#       case x::xs -> if (x.nick == nick) tl(users)
#                     else hd(users)::removeUserByName(nick, xs)
#     }
#   }
#
#   fun muteUserByName(nick, users) {
#     switch(users) {
#       case [] -> []
#       case x::xs ->
#         if (x.nick == nick)
#           (x with isMuted=not(x.isMuted)) :: xs
#         else x::muteUserByName(nick, xs)
#     }
#   }
#
#   fun makeModeratorByName(nick, users) {
#     switch(users) {
#       case [] -> []
#       case x::xs ->
#         if (x.nick == nick) (x with isAdmin=true) :: xs
#         else x::makeModeratorByName(nick, xs)
#     }
#   }
#
#   fun isMuted(nick, users) {
#     switch(users) {
#       case [] -> true
#       case x::xs -> if (x.nick == nick) x.isMuted
#                     else isMuted(nick, xs)
#     }
#   }
#
#   receive {
#     case BroadcastMessage(nick, msg) ->
#       var users = if (isMuted(nick, status.users)) []
#                   else status.users;
#       broadcastMessage(DeliverMessage(nick, msg), users);
#       perRoomLoop(status)
#     case BroadcastChangeTopic(newTopic) ->
#       broadcastMessage(DeliverNewTopic(newTopic), status.users);
#       perRoomLoop((status with topic=newTopic))
#     case NewClient(nick, pid) ->
#       broadcastMessage(DeliverNewUser(nick), status.users);
#       var new_user =
#         (nick=nick, pid=pid, isAdmin=false, isMuted=false);
#       var new_users = new_user::(status.users);
#       perRoomLoop((status with users=new_users))
#     case GetRoomState(pid) ->
#       pid ! (status.name, status.topic, status.users);
#       perRoomLoop(status)
#     case RemoveUser(nick) ->
#       var matchingUsers = filter(fun (x) { x.nick==nick }, status.users);
#       if (matchingUsers == [])
#         perRoomLoop(status)
#       else {
#         var users = filter(fun (x) { x.nick<>nick }, status.users);
#         broadcastMessage(DeliverLeave(), matchingUsers);
#         broadcastMessage(DeliverUserLeft(nick), users);
#         perRoomLoop((status with users=users))
#       }
#     case MuteUser(nick) ->
#       var is_muted = filter( fun(x){ x.nick==nick && x.isMuted },
#                                      status.users) == [];
#       if (is_muted)
#         broadcastMessage(DeliverUserMuted(nick), status.users)
#       else
#         broadcastMessage(DeliverUserUnmuted(nick), status.users);
#       var users = muteUserByName(nick, status.users);
#       perRoomLoop((status with users=users))
#     case MakeModerator(nick) ->
#       var nonModeratorNicks =
#         filter( fun(x) { x.nick==nick && x.isAdmin==false }, status.users );
#       if (nonModeratorNicks == [])
#         perRoomLoop(status)
#       else {
#         var userNames = for (x<-status.users) { [x.nick] };
#         broadcastMessage(DeliverBecameModerator(userNames), nonModeratorNicks);
#         var users = makeModeratorByName(nick, status.users);
#         perRoomLoop((status with users=users))
#       }
#   }
# }

# Send all existing rooms to the client
# The client then either picks one of the existing rooms or creates a new one,
# and sends its choice back to the client.
# The server then allocates a handle for that particular room, for client
# to operate on
typename WorkerResult = [| SameRoom:ClientSend | LeftRoom |];

sig acceptAndWork : (ServerAccept) ~> ()
fun acceptAndWork(s) server {

  # Main loop: offers on WorkerReceive channel, communicates
  # with room
  sig workerLoop : (Nickname, RoomHandle, WorkerReceive) ~> ()
  fun workerLoop(nick, roomHandle, s) {
    try {
      offer(s) {
        case ChatMessage(s) ->
          var (msg, s) = receive(s);
          debug("worker loop for " ^^ nick ^^ ": sending message " ^^ msg);
          Room.chatMessage(roomHandle, nick, msg);
          SameRoom(s)
        case ChangeTopic(s) ->
          var (topic, s) = receive(s);
          Room.newTopic(roomHandle, topic);
          SameRoom(s)
        case Leaving(_) ->
          Room.leave(roomHandle, nick);
          LeftRoom
      }
    } as (result) in {
      switch(result) {
        case SameRoom(s) -> workerLoop(nick, roomHandle, s)
        case LeftRoom -> ()
      }
    } otherwise {
      Room.leave(roomHandle, nick)
    }
  }

  # Get all available rooms from the room manager
  var rooms = RoomManager.listRooms();
  # send the rooms to the client.
  var s = send(rooms, s);
  # get the room selection from the client
  var ((room, nick), s) = receive(s);
  var joinResult = RoomManager.connectToRoom(nick, room);
  switch(joinResult) {
    case UsernameTaken ->
      var s = select Nope s;
      ignore(send(NameInUse, s))
    case InvalidRoom ->
      var s = select Nope s;
      ignore(send(BadRoom, s))
    case Joined(topic, clientReceive, roomAP) ->
      var s = select JoinedOK s;
      var s = send((topic, clientReceive), s);
      workerLoop(nick, roomAP, s)
    case JoinedAsModerator(topic, clientReceive, moderatorSend, roomAP) ->
      var s = select JoinedOKAsModerator s;
      var s = send((topic, clientReceive, moderatorSend), s);
      workerLoop(nick, roomAP, s)
  }
}

sig acceptor : () ~> ()
fun acceptor() server {
  # Accept a new client from worker AP (defined in ChatSessions)
  var s = accept(wap);
  var _ = spawn { acceptAndWork(s) };
  acceptor()
}


fun main() {
  var clientAP = new();
  RoomManager.init();
  var _ = spawn { acceptor() };
  addRoute("/", fun (_) { ChatClient.mainPage() } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets();
  servePages()
}

main()
