open ChatSessions
open ChatClient
open Utility

#helper functions:
fun member(elem , l) {
  switch(l) {
    case [] -> false
    case (x::xs) -> x == elem || member(elem, xs)
  }
}

# Messages sent from workers and the room manager to
# a room. Note that is *not* exposed to clients directly.
# It is, however, the union of both the messages sent by
# client workers and the room manager.
# In future, I wonder whether some form of input-guarded choice-style
# operator on APs could make this more modular.
typename RoomReceive =
  [&|
      # Messages sent from client worker
      Chat: ?(Nickname, Message).End,
      NewTopic: ?Topic          .End,
      Leave: ?Nickname          .End,
      # Messages sent from room manager
      JoinRequest: ?Nickname.!RoomJoinResponse.End,
      Kill: End
  |&];

typename RoomHandle = AP(RoomReceive);

typename RoomJoinResponse =
  [| | UsernameTaken
     | InvalidRoom
     | Joined: (Topic, ClientReceive, RoomHandle)
     | JoinedAsModerator:
     (Topic, ClientReceive, RoomHandle, ModeratorSend) |];


module Moderator {
  sig create : (AP(RoomReceive)) ~> ModeratorSend
  fun create(roomAp) {
    linfun loop(s) {
      offer(s) {
        case RemoveUser(s) ->
          var (nick, s) = receive(s);
          # TODO: send message to AP here
          loop(s)
        case MuteUser(s) ->
          var (nick, s) = receive(s);
          # TODO: send message to AP here loop(s)
        case MakeModerator(s) ->
          var (nick, s) = receive(s);
          # TODO: send message to AP here
          loop(s)
      }
    }
    fork(s)
  }
}

module Room {

  typename RoomState =
    (name:String,
     topic:String,
     nicknames:[Nickname],
     moderators:[Nickname],
     ap:AP(RoomReceive),
     clients:LinList(WorkerSend));

  # Gets us a pair of (RoomSend, ~RoomSend) endpoints.
  # Perhaps this should be in the standard library.
  sig createRoomSend : () ~> (RoomSend, ~RoomSend)
  fun createRoomSend() {
    var transit = new();
    var (ap: AP(RoomSend)) = new();
    var _ = spawn {
      var ep2 = request(ap);
      ignore(send(ep2, request(transit)))
    };
    var ep1 = accept(ap);
    var (ep2, _) = receive(accept(transit));
    (ep1, ep2)
  }

  fun loop(state) {
    fun broadcastJoined(nick, clients) {
      linMap(fun(s) {
        var s = select UserJoined s;
        send(nick, s)
      }, state.clients)
    }

    offer(s) {
      case JoinRequest(s) ->
        var (nick, s) = receive(s);
        # If username is already taken, let the client know
        if (contains(nick, state.nicknames)) {
          var _ = send(UsernameTaken, s);
          loop(state)
        } else {
          # Otherwise, check if that username is a moderator.
          if (contains(nick, state.moderators)) {
            var (roomSend, clientReceive) = createRoomSend();
            var moderatorSend = Moderator.create(state.ap);
            # Broadcast that the user has joined
            var clients = broadcastJoined(nick, state.clients);
            var _ =
              send(JoinedAsModerator(state.topic,
                clientReceive, moderatorSend), s);
            loop((state with
              nicknames=nick :: state.nicknames,
              clients=LinCons(roomSend, clients)))
          } else {
            var (roomSend, clientReceive) = createRoomSend();
            var clients = broadcastJoined(nick, state.clients);
            var _ = send(Joined(state.topic, clientReceive)
            loop((state with
              nicknames=nick :: state.nicknames,
              clients=LinCons(roomSend, clients)))
          }
        }
      case Chat(s) ->
        var ((nick, msg), _) = receive(s);
        var clients = linMap(fun(s) {
          var s = select IncomingChatMessage s;
          send (nick, msg)
        }, state.clients);
        loop((state with clients=clients))
      case NewTopic(s) ->
        var (newTopic, _) = receive(s);
        var clients = linMap(fun(s) {
          var s = select NewTopic s;
          send(newTopic, s)
        }, state.clients);
        loop((state with topic=newTopic, clients=clients))
      case Leave(s, nick) ->
        var (name, _) = receive(s);
        var clients = linMap(fun(s) {
          var s = select UserLeft s;
          var s = send(name, s);
          s
        }, state.clients);
        loop((state with clients=clients))
      case Kill ->
        var clients = state.clients;
        # Since after selecting Kick, all elements will be of type End
        # (and therefore unrestricted), we can dispose of `clients`.
        var _ = linMap(fun(s) { select Kick s }, state.clients);
        () # Stop evaluating
    }
  }

  sig join : (Nickname, RoomHandle) ~> RoomJoinResponse
  fun join(nick, ap) {
    var s = s.request(ap);
    var s = send(nick, s);
    var (res, _) = receive(s);
    s
  }

  sig create : (RoomName) ~> RoomHandle
  fun create(roomName) {
    var ap = new();
    var state = (name=roomName, topic="Hello, world!", ap=ap, clients=LinNil);
    var _ = spawn { loop(state) };
    ap
  }

  sig kill : (RoomHandle) ~> ()
  fun kill(ap) {
    ignore(select Kill ap)
  }

  sig chatMessage(RoomHandle, Nickname, Message) ~> ()
  fun chatMessage(ap, nick, msg) {
    var s = request(ap);
    var s = select Chat s;
    ignore(send((nick, msg), s))
  }

  sig newTopic(RoomHandle, Topic) ~> ()
  fun newTopic(ap, topic) {
    var s = request(ap);
    var s = select NewTopic s;
    ignore(send(topic, s))
  }

  sig leave(RoomHandle, Nickname) ~> ()
  fun leave(ap, nick) {
    var s = request(ap);
    var s = select UserLeft s;
    ignore(send(nick, s))
  }

}


module RoomManager {

  # Messages sent from the client to add / remove
  # / list / join rooms
  typename RoomManager =
    [&|
      AddRoom: ?RoomName.!Bool.End, # Bool: whether add was successful
      RemoveRoom: ?RoomName.End,
      ListRooms: ![RoomName].End,
      ConnectToRoom: ?(Nickname, RoomName).!RoomJoinResponse.End
    |&]


  sig managerAP : AP(RoomManager)
  var managerAP = new();


  fun roomExists(roomName, rooms) {
    StringAssocList.contains(roomName, rooms)
  }

  fun lookupRoom(roomName, rooms) {
    StringAssocList.lookup(roomName, rooms)
  }

  fun removeRoom(roomName, rooms) {
    switch StringAssocList.lookup(roomName, rooms) {
      case Just(roomHandle) ->
        Room.kill(roomHandle)
        filter(fun(name, _) { name != roomName }, rooms)
      case None -> rooms
    }
  }

  # Main loop for the room manager
  fun loop(rooms) {
    var s = accept(managerAP);
    offer(s) {
      case AddRoom(s) ->
        var (name, s) = receive(s);
        # Create room if it doesn't exist, notify client of outcome
        if (roomExists(name)) {
          var room = Room.create(name);
          var _ = send(true, s);
          loop(rooms ++ [room])
        } else {
          var _ = send(false, s);
          loop(rooms)
        }
      case RemoveRoom(s) ->
        var (roomName, _) = receive(s);
        loop(removeRoom(roomName, rooms))
      case ListRooms(s) ->
        var _ = send(map(fun(name, _) { name }, rooms), s);
        loop(rooms)
      case ConnectToRoom(s) ->
        var ((nick, roomName), s) = receive(s);
        switch(lookup(roomName, rooms)) {
          case Just(room) ->
            var joinResult = Room.join(nick, roomName);
            var _ = send(joinResult, s);
            loop(rooms)
          case Nothing ->
            var _ = send(InvalidRoom, s);
            loop(rooms)
        }
    }
  }

  var supervisorPid = spawn { loop([]) }

  fun addRoom(name) {
    var s = request(managerAP);
    var s = select AddRoom s;
    var s = send(name, s);
    var (res, _) = receive(s);
    res
  }

  fun removeRoom(name) {
    var s = request(managerAP);
    var s = select RemoveRoom s;
    ignore(send(name, s))
  }

  fun listRooms() {
    var s = request(managerAP);
    var s = select ListRooms s;
    var (rooms, _) = receive(s);
    rooms
  }

  fun connectToRoom(name, roomName) {
    var s = request(managerAP);
    var s = select ConnectToRoom s;
    var s = send(name, roomName);
    var (res, _) = receive(s);
    res
  }
}

# Messages directed form the server to the client
# fun clientSendHandler(s) {
#   receive {
#     case DeliverMessage(nick, msg) ->
#       var s = select IncomingChatMessage s;
#       var s = send((nick, msg), s);
#       clientSendHandler(s)
#     case DeliverNewUser(nick) ->
#       var s = select NewUser s;
#       var s = send(nick, s);
#       clientSendHandler(s)
#     case DeliverNewTopic(topic) ->
#       var s = select NewTopic s;
#       var s = send(topic, s);
#       clientSendHandler(s)
#     case DeliverUserLeft(nick) ->
#       var s = select UserLeft s;
#       var s = send(nick, s);
#       clientSendHandler(s)
#     case DeliverUserMuted(nick) ->
#       var s = select UserMuted s;
#       var s = send(nick, s);
#       clientSendHandler(s)
#     case DeliverUserUnmuted(nick) ->
#       var s = select UserUnmuted s;
#       var s = send(nick, s);
#       clientSendHandler(s)
#     case DeliverLeave() ->
#       select Leave s
#     case DeliverBecameModerator(nicks) ->
#       var s = select MakeModerator s;
#       var s = send(nicks, s);
#       clientSendHandler(s)
#   }
# }

# status : ( name:Room, topic:Topic, users:[User] )
# user : ( nick:Nickname, pid:ClientSendHandler, isAdmin:Bool,
#          isMuted:Bool )
# Main server loop that handles an individual room
# fun perRoomLoop(status) server {
#   fun removeUserByName(nick, users) {
#     switch(users) {
#       case [] -> []
#       case x::xs -> if (x.nick == nick) tl(users)
#                     else hd(users)::removeUserByName(nick, xs)
#     }
#   }
#
#   fun muteUserByName(nick, users) {
#     switch(users) {
#       case [] -> []
#       case x::xs ->
#         if (x.nick == nick)
#           (x with isMuted=not(x.isMuted)) :: xs
#         else x::muteUserByName(nick, xs)
#     }
#   }
#
#   fun makeModeratorByName(nick, users) {
#     switch(users) {
#       case [] -> []
#       case x::xs ->
#         if (x.nick == nick) (x with isAdmin=true) :: xs
#         else x::makeModeratorByName(nick, xs)
#     }
#   }
#
#   fun isMuted(nick, users) {
#     switch(users) {
#       case [] -> true
#       case x::xs -> if (x.nick == nick) x.isMuted
#                     else isMuted(nick, xs)
#     }
#   }
#
#   receive {
#     case BroadcastMessage(nick, msg) ->
#       var users = if (isMuted(nick, status.users)) []
#                   else status.users;
#       broadcastMessage(DeliverMessage(nick, msg), users);
#       perRoomLoop(status)
#     case BroadcastChangeTopic(newTopic) ->
#       broadcastMessage(DeliverNewTopic(newTopic), status.users);
#       perRoomLoop((status with topic=newTopic))
#     case NewClient(nick, pid) ->
#       broadcastMessage(DeliverNewUser(nick), status.users);
#       var new_user =
#         (nick=nick, pid=pid, isAdmin=false, isMuted=false);
#       var new_users = new_user::(status.users);
#       perRoomLoop((status with users=new_users))
#     case GetRoomState(pid) ->
#       pid ! (status.name, status.topic, status.users);
#       perRoomLoop(status)
#     case RemoveUser(nick) ->
#       var matchingUsers = filter(fun (x) { x.nick==nick }, status.users);
#       if (matchingUsers == [])
#         perRoomLoop(status)
#       else {
#         var users = filter(fun (x) { x.nick<>nick }, status.users);
#         broadcastMessage(DeliverLeave(), matchingUsers);
#         broadcastMessage(DeliverUserLeft(nick), users);
#         perRoomLoop((status with users=users))
#       }
#     case MuteUser(nick) ->
#       var is_muted = filter( fun(x){ x.nick==nick && x.isMuted },
#                                      status.users) == [];
#       if (is_muted)
#         broadcastMessage(DeliverUserMuted(nick), status.users)
#       else
#         broadcastMessage(DeliverUserUnmuted(nick), status.users);
#       var users = muteUserByName(nick, status.users);
#       perRoomLoop((status with users=users))
#     case MakeModerator(nick) ->
#       var nonModeratorNicks =
#         filter( fun(x) { x.nick==nick && x.isAdmin==false }, status.users );
#       if (nonModeratorNicks == [])
#         perRoomLoop(status)
#       else {
#         var userNames = for (x<-status.users) { [x.nick] };
#         broadcastMessage(DeliverBecameModerator(userNames), nonModeratorNicks);
#         var users = makeModeratorByName(nick, status.users);
#         perRoomLoop((status with users=users))
#       }
#   }
# }

# Send all existing rooms to the client
# The client then either picks one of the existing rooms or creates a new one,
# and sends its choice back to the client.
# The server then allocates a handle for that particular room, for client
# to operate on
typename WorkerResult = [| SameRoom:ClientSend | LeftRoom |];

sig acceptAndWork : (ServerAccept) ~> ()
fun acceptAndWork(s) server {

  # Main loop: offers on ClientReceive channel, communicates
  # with room
  fun workerLoop(nick, roomHandle, s) {
    try {
      offer(s) {
        case ChatMessage(s) ->
          var (msg, s) = receive(s);
          Room.chat(roomHandle, nick, msg);
          SameRoom(s)
        case ChangeTopic(s) ->
          var (topic, s) = receive(s);
          Room.changeTopic(roomHandle, topic);
          SameRoom(s)
        case Leaving ->
          Room.leave(roomHandle, nick);
          LeftRoom
      }
    } as (result) in {
      switch(result) {
        case SameRoom(s) -> workerLoop(s)
        case LeftRoom -> ()
      }
    } otherwise {
      Room.leave(roomHandle, nick)
    }
  }

  # Get all available rooms from the room manager
  var rooms = RoomManager.listRooms();
  # send the rooms to the client.
  var s = send(rooms, s);
  # get the room selection from the client
  var ((room, nick), s) = receive(s);
  var joinResult = RoomManager.connectToRoom(nick, room);
  switch(joinResult) {
    case UsernameTaken -> ignore(send(NameInUse, s))
    case InvalidRoom -> ignore(send(BadRoom, s))
    case Joined(topic, clientReceive, roomHandle) ->
      var s = select Joined s;
      var s = send((topic, clientReceive), s);
      workerLoop(nick, roomHandle, s)
    case JoinedAsModerator(topic, clientReceive, ap, moderatorSend) ->
      var s = select JoinedAsModerator s;
      var s = send((topic, clientReceive, moderatorSend), s);
      workerLoop(nick, roomHandle, s)
  }
}

sig acceptor : (AP(ServerAccept)) ~> ()
fun acceptor(ap) server {
  # Accept a new client
  var s = accept(ap);
  var _ = spawn { acceptAndWork(s) };
  clientAcceptor(ap, loopPid)
}


fun main() {
  var clientAP = new();
  # spawn loop that keeps track of existing rooms and their handlers
  var loopPid = spawn { roomsLoop([], []) };

  var _ = spawn { clientAcceptor(clientAP, loopPid) };
  addRoute("/", fun (_) { ChatClient.mainPage(clientAP) } );
  addStaticRoute("/css", "css", [("css", "text/css")]);
  serveWebsockets();
  servePages()
}

main()
